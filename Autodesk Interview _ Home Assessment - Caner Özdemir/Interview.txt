Alright let's start with CMake, it is based on CMake, in this way, I can just open up the project on any Integrated Development Environment, I used CLion for this one, I tried to keep CMakeLists file as simple as I can, it is configured for being a standalone application
I used MSYS2 as development platform, we can quickly install almost any kind of open source libraries which are compiled with MinGW or Clang compiler, cuz you know, for C and C++ there are other compilers named Visual C, Visual C++ as well, if our project is compiled with different compiler than our library, we will end up with countless errors and problems, there is even no guarantee for different versions of same compiler. These are called toolchains, you know. On my previous project, I had dealed in OpenCV at basic level with Qt and C++. Thanks to MSYS2, I didnt suffer these kind of problems, everything has been integrated seamlessly
Now let's switch to main.cpp, the entry point of the application. I adjusted two things here, style and stylesheet, I had a basic dark stylesheet from one of my previous projects and I modified it to fit here
Let's check it out, I have added things like QScrollArea, QScrollBar, QColorDialog as well as QMenuBar, modified things like QMenu, QSpinBox, QDoubleSpinBox as far as I remember
To reach exact same look on all operating systems, the style must be Fusion otherwise there will be slight differences among different operating systems for components like QScrollBar, QScrollArea, QMenuBar, QMenu
I get initial values from a configuration class, let's check it out, for now it is just hard-coded but it can be easily converted to read values from a configuration file like xml, json or old good ini file type or even from a database, I put style file and initial image as resource but it can be read from an external file which may have a relative location starts from binary file location or these paths can be set by environment variables as well
There is a mainwindow.ui file, I created it using Qt Designer, I try to design graphical user interfaces as much as resizable, therefore, I have put a QScrollArea, it also helps to zoom-in and zoom-out, that ScrollArea has a dynamic size depending on MainWindow size, other elements are fixed-width and fixed-height in this example, sometimes Qt Designer may lack a spesific thing, for this example, I couldnt copy QMenuBar from one ui to other, I couldnt delete the widget on QScrollArea by using Qt Designer, I fixed them manually in a text editor, it is xml format anyway
I use svg image files on buttons (including arrow images on SpinBox :)) to make it compatible with resizing, you know, unlike bitmaps, vector images dont lose its quality over different resolutions
Let's check out mainwindow class, I tried to keep it as a container which connects different components, for this example, all components manage PaintArea widget which has one instance named as Image_QWidget therefore I gave a direct pointer to make kind of late initilization. I generally do this type of workflow on my personal projects but I can adopt any other workflow as well, I try to relate between objects as a parent and a child hierarchy which means the parent has to control the child and the child may control the parent but I make one thing sure, the parent has to have more controls over child, otherwise it wouldnt be a child, right :) in that case I switch the child as the parent and the parent as the child
And the most important key point is if I have to control from child to parent, I never ever do this directly, cuz if I give a pointer from that to this and this to that, eventually it will end up circular logic problems just like circular dependencies, similar like deadlocks on threads, I make it indirect communication with signal and slot mechanism on qt. Signals and slots in qt are great implementation of observer pattern
Let's now check out components, starting with menubar, this menubar has a simple File menu which has a simple Open submenu, I connect signals and slots manually after late initilization to prevent null pointer errors, Open_Action simply opens an image file by using QFileDialog and sets image source of paint area
Let's now go to pen and eraser tools, there are two types of tools, a pen and an eraser, these both simply set the tool of paint area, pretty straight-forward
We have a few options which affect at least one tool
The first one, pen size, affects both pen and eraser tools
The second one, pen color, affects only pen tool, it opens up a QColorDialog to pick a color and it also updates its current icon to reflect selected color
The third one, pen opacity, affects both tools, I know it can actually be readed from Color Picker but I disabled it intentionally, I think it needs its own controller rather than dealing with Color Dialog back and forth in order to get easier user experience
The forth one, zoom, affects both tools, they all manage main paint area by passing their values, these values are used in drawing
I have gathered up business logic in paint area. I created penBrush and penCursor beforehand to save recreation overhead, cuz these two brushes are used over and over again with slight modifications
I set up two drawing layers to make erasing operation possible, the first layer is for background, alpha channel is ignored in first layer, the second layer is for drawing, image is created with alpha channel to blend together and I set up one extra copy of these two layers to make zoom operations possible. Therefore I have two pixmaps and two images, background images are pixmap type cuz once it is set, there wont be any other modifications until opening another picture file. Image resolution operations are done with high quality. However inside of real time drawing, layer is scaled with fast quality until drawing cycles complete with mouse release event for the sake of performance
I also set up a cursor, this cursor changes its size and color depending on tool itself and tool size and tool color
Drawing cycles only call updates on the limited area which drawing occurs. I also call one full update after drawing ends cuz foreground layer has to be fully resized one last time at high quality instead of fast quality
I tried organize the hierarchy clearly and tried to define a standard and use that standard in all along cuz I think even when we define a wrong standard, we can fix it up, transform it up to the exact right standard easier if we consistently obey that standard, because we keep that pattern and we can find a way to reach that consistent pattern, I tried to mimic a complete full standalone product, I even have put window icons :)
I gathered required dlls by using windeployqt for Windows operating system, however it couldnt get all required dlls so I placed rest of them manually according to error messages, I got them from MSYS2 MinGW64 folder, even with this, I had problems at runtime so I found a few required dlls which take place on opening image files and have put manually as well